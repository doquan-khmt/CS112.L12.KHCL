1. Abstraction: tìm ra mảng con có tổng lớn nhất.

2. Pattern Recognition:
+ Sử dụng vét cạn nếu không yêu cầu về thời gian xử lí: Duyệt tất cả đoạn con
+ Sử dụng qui hoạch động để tối ưu về thời gian: ta sử dụng một biến tạm để lưu trữ tổng giá trị đến thời
điểm hiện tại. Ta thấy có 3 trường hợp xảy ra:
    * nếu biến tạm lớn hơn biến kết quả thì cập nhật kết quả = biến tạm
    * nếu biến tạm bé hơn biến kết và không bé hơn không, ta vẫn cộng giá trị của mảng và duyệt tiếp
    * nếu biến tạm bé hơn 0, lúc này đoạn con cập nhật tới thời điểm hiện tại không còn ý nghĩa nữa vì nếu
    cộng tiếp tục giá trị tiếp theo, nếu là số dương thì dương + âm vẫn bé hơn số dương đó, nếu là số âm thì
    đoạn càng giảm.

3. Algorithm designed:

*** a là mảng lưu các các giá trị lãi ở đoạn đường thứ i

+ Vét cạn:
    Khởi tạo: start = end = 0
              max_sub_array = âm vô hạn
    for i = 0 -> N:
        max_ending_here = 0
        for j = i -> N:
            max_ending_here += a[i]
            nếu max_ending_here > max_sub_array (tức có một mảng con tốt hơn hiện tại):
                cập nhật max_sub_array, start, end

    xuất start, end, max_sub_array

+ Qui hoạch động:
    Khởi tạo: start = temp_start = end = 0,
              max_ending_here = a[0], max_sub_array = âm vô hạn

    for i = 1 -> N:
        max_ending_here += a[i]
        nếu max_ending_here > max_sub_array:
            cập nhật: max_sub_array = max_ending_here
                      start = temp_start
                      end = i

        nếu max_ending_here < 0:
            gán max_ending_here = 0
            gán temp_start = i + 1 (chỉ quan tâm tới đoạn tiếp theo)

     xuất max_sub_array, start, end